import React from 'react';
import { interaction, storage } from 'uxp';
import { app, action, core } from 'photoshop';
import { BLEND_MODES } from './constants/blendModes';
import { BLEND_MODE_OPTIONS } from './constants/blendModeOptions';
import { AppState, initialState, Gradient } from './types/state';
import { DragHandler } from './utils/DragHandler';
import { FillHandler } from './utils/FillHandler';
import { LayerInfoHandler } from './utils/LayerInfoHandler';
import { ClearHandler } from './utils/ClearHandler';
import ColorSettingsPanel from './components/ColorSettingsPanel';
import PatternPicker from './components/PatternPicker';
import GradientPicker from './components/GradientPicker';
import StrokeSetting from './components/StrokeSetting';
import LicenseDialog from './components/LicenseDialog';
import { LicenseManager } from './utils/LicenseManager';
import { ExpandIcon, SettingsIcon } from './styles/Icons';
import { calculateRandomColor, hsbToRgb, rgbToGray } from './utils/ColorUtils';
import { strokeSelection } from './utils/StrokeSelection';
import { PatternFill } from './utils/PatternFill';
import { GradientFill } from './utils/GradientFill';
import { SingleChannelHandler } from './utils/SingleChannelHandler';
import { SelectionHandler, SelectionOptions } from './utils/SelectionHandler';
import { ColorSettings, Pattern } from './types/state';

const { executeAsModal } = core;
const { batchPlay } = action;

interface AppProps {}

class App extends React.Component<AppProps, AppState> {
    private isListenerPaused = false;
    private isInLayerMask = false;
    private isInQuickMask = false;
    private isInSingleColorChannel = false;
    private selectionChangeListener: any = null;

    constructor(props: AppProps) {
        super(props);
        this.state = initialState;
        
        this.handleSelectionChange = this.handleSelectionChange.bind(this);
        this.handleOpacityChange = this.handleOpacityChange.bind(this);
        this.handleFeatherChange = this.handleFeatherChange.bind(this);
        this.handleBlendModeChange = this.handleBlendModeChange.bind(this);
        this.toggleAutoUpdateHistory = this.toggleAutoUpdateHistory.bind(this);
        this.handleButtonClick = this.handleButtonClick.bind(this);
        this.toggleDeselectAfterFill = this.toggleDeselectAfterFill.bind(this);
        this.handleLabelMouseDown = this.handleLabelMouseDown.bind(this);
        this.handleMouseMove = this.handleMouseMove.bind(this);
        this.handleMouseUp = this.handleMouseUp.bind(this);
        this.toggleCreateNewLayer = this.toggleCreateNewLayer.bind(this);
        this.toggleClearMode = this.toggleClearMode.bind(this);
        this.toggleColorSettings = this.toggleColorSettings.bind(this);
        this.openPatternPicker = this.openPatternPicker.bind(this);
        this.openGradientPicker = this.openGradientPicker.bind(this);
        this.handleColorSettingsSave = this.handleColorSettingsSave.bind(this);
        this.handlePatternSelect = this.handlePatternSelect.bind(this);
        this.handleGradientSelect = this.handleGradientSelect.bind(this);
        this.handleFillModeChange = this.handleFillModeChange.bind(this);
        this.toggleExpand = this.toggleExpand.bind(this);
        this.closeColorSettings = this.closeColorSettings.bind(this);
        this.closePatternPicker = this.closePatternPicker.bind(this);
        this.closeGradientPicker = this.closeGradientPicker.bind(this);
        this.closeStrokeSetting = this.closeStrokeSetting.bind(this);
        this.toggleStrokeEnabled = this.toggleStrokeEnabled.bind(this);
        this.toggleStrokeSetting = this.toggleStrokeSetting.bind(this);
        // Êñ∞Â¢ûÁªëÂÆö
        this.toggleSelectionOptions = this.toggleSelectionOptions.bind(this);
        this.handleSelectionSmoothChange = this.handleSelectionSmoothChange.bind(this);
        this.handleSelectionContrastChange = this.handleSelectionContrastChange.bind(this);
        this.handleSelectionExpandChange = this.handleSelectionExpandChange.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
        // ËÆ∏ÂèØËØÅÁõ∏ÂÖ≥ÊñπÊ≥ïÁªëÂÆö
        this.handleLicenseVerified = this.handleLicenseVerified.bind(this);
        this.handleTrialStarted = this.handleTrialStarted.bind(this);
        this.closeLicenseDialog = this.closeLicenseDialog.bind(this);
        this.checkLicenseStatus = this.checkLicenseStatus.bind(this);
        this.openLicenseDialog = this.openLicenseDialog.bind(this);
        this.resetLicenseForTesting = this.resetLicenseForTesting.bind(this);
 
    }

    async componentDidMount() {
        this.selectionChangeListener = (eventName, descriptor) => {
            // Ê£ÄÊü•ÊòØÂê¶ÊòØÈÄâÂå∫Áõ∏ÂÖ≥ÁöÑset‰∫ã‰ª∂
            if (descriptor && descriptor._target && Array.isArray(descriptor._target)) {
                const isSelectionEvent = descriptor._target.some(target => 
                    target._ref === 'channel' && target._property === 'selection'
                );
                
                if (isSelectionEvent) {
                    this.handleSelectionChange(descriptor);
                } else {
                    console.log('üîç ÈùûÈÄâÂå∫ËÆæÁΩÆ‰∫ã‰ª∂ÔºåË∑≥ËøáÂ§ÑÁêÜ');
                }
            }
        };
        await action.addNotificationListener(['set'], this.selectionChangeListener);
        document.addEventListener('mousemove', this.handleMouseMove);
        document.addEventListener('mouseup', this.handleMouseUp);
        
        // ÂàùÂßãÂåñÁä∂ÊÄÅÊ£ÄÊµã
        await this.checkMaskModes();
        
        // ÁõëÂê¨Photoshop‰∫ã‰ª∂Êù•Ê£ÄÊü•Áä∂ÊÄÅÂèòÂåñ
        await action.addNotificationListener(['set', 'select', 'clearEvent', 'delete', 'make'], this.handleNotification);

        // ËÆ∏ÂèØËØÅÔºöÊ£ÄÊü•ÂΩìÂâçÁä∂ÊÄÅÂπ∂Â∞ùËØïËá™Âä®ÈáçÊñ∞È™åËØÅ
        await this.checkLicenseStatus();
    }

    componentDidUpdate(prevProps, prevState) {
        // Ê£ÄÊü•Ê¨°Á∫ßÈù¢ÊùøÁä∂ÊÄÅÂèòÂåñÔºåÊ∑ªÂä†ÊàñÁßªÈô§CSSÁ±ª
        const isAnySecondaryPanelOpen = this.state.isColorSettingsOpen || 
                                       this.state.isPatternPickerOpen || 
                                       this.state.isGradientPickerOpen || 
                                       this.state.isStrokeSettingOpen;
        
        const wasAnySecondaryPanelOpen = prevState.isColorSettingsOpen || 
                                        prevState.isPatternPickerOpen || 
                                        prevState.isGradientPickerOpen || 
                                        prevState.isStrokeSettingOpen;
        
        if (isAnySecondaryPanelOpen !== wasAnySecondaryPanelOpen) {
            if (isAnySecondaryPanelOpen) {
                document.body.classList.add('secondary-panel-open');
            } else {
                document.body.classList.remove('secondary-panel-open');
            }
        }

        // Ê£ÄÊü•ÊéàÊùÉÂØπËØùÊ°ÜÁä∂ÊÄÅÂèòÂåñÔºåÊ∑ªÂä†ÊàñÁßªÈô§CSSÁ±ª
        if (this.state.isLicenseDialogOpen !== prevState.isLicenseDialogOpen) {
            if (this.state.isLicenseDialogOpen) {
                document.body.classList.add('license-dialog-open');
            } else {
                document.body.classList.remove('license-dialog-open');
            }
        }
    }

    componentWillUnmount() {
        if (this.selectionChangeListener) {
            action.removeNotificationListener(['set'], this.selectionChangeListener);
        }
        action.removeNotificationListener(['set', 'select', 'clearEvent', 'delete', 'make'], this.handleNotification);
        document.removeEventListener('mousemove', this.handleMouseMove);
        document.removeEventListener('mouseup', this.handleMouseUp);
        // Ê∏ÖÁêÜCSSÁ±ª
        document.body.classList.remove('secondary-panel-open');
        document.body.classList.remove('license-dialog-open');
    }

    handleButtonClick() {
        this.setState(prevState => ({
            isEnabled: !prevState.isEnabled
        }));
    }


    // Êñ∞Â¢ûÊñπÊ≥ï
    toggleSelectionOptions() {
        this.setState(prevState => ({
            isSelectionOptionsExpanded: !prevState.isSelectionOptionsExpanded
        }));
    }

    handleSelectionSmoothChange(event) {
        this.setState({ selectionSmooth: parseInt(event.target.value, 10) });
    }

    handleSelectionContrastChange(event) {
        this.setState({ selectionContrast: parseInt(event.target.value, 10) });
    }

    handleSelectionExpandChange(event) {
        this.setState({ selectionExpand: parseInt(event.target.value, 10) });
    }

    // Â∫îÁî®ÈÄâÂå∫‰øÆÊîπ
    async applySelectionModification() {
        const options: SelectionOptions = {
            selectionSmooth: this.state.selectionSmooth,
            selectionContrast: this.state.selectionContrast,
            selectionExpand: this.state.selectionExpand
        };
        
        try {
            await SelectionHandler.applySelectionModification(options);
        } catch (error) {
            console.error('ÈÄâÂå∫‰øÆÊîπÂ§±Ë¥•:', error);
        }
    }

    toggleExpand() {
        this.setState(prevState => {
            const isExpanded = !prevState.isExpanded;
            return { isExpanded };
        });
    }

    toggleStrokeEnabled() {
        this.setState({ strokeEnabled: !this.state.strokeEnabled });
    }
    
    toggleClearMode() {
        this.setState(prevState => ({
            clearMode: !prevState.clearMode,
            createNewLayer: prevState.clearMode ? prevState.createNewLayer : false // Â¶ÇÊûúÂºÄÂêØÊ∏ÖÈô§Ê®°ÂºèÔºåÂÖ≥Èó≠Êñ∞Âª∫ÂõæÂ±ÇÊ®°Âºè
        }));
    }

    handleFillModeChange(event: CustomEvent) {
        try {
            if (!this || !this.state || !event || !event.target) {
                return;
            }
            const value = event.target.selected;
            this.setState({ fillMode: value });
        } catch (error) {
        }
    }

    toggleStrokeSetting() {
        this.setState({ isStrokeSettingOpen: true });
    }

    toggleColorSettings() {
        this.setState(prev => ({ isColorSettingsOpen: !prev.isColorSettingsOpen }));
    }

    openPatternPicker() {
        this.setState({ isPatternPickerOpen: true });
    }

    openGradientPicker() {
        this.setState({ isGradientPickerOpen: true });
    }

    handleColorSettingsSave(settings: ColorSettings) {
        try {
            // È™åËØÅËÆæÁΩÆÂÄºÊòØÂê¶Âú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
            const validatedSettings = {
                hueVariation: Math.min(360, Math.max(0, settings.hueVariation)),
                saturationVariation: Math.min(100, Math.max(0, settings.saturationVariation)),
                brightnessVariation: Math.min(100, Math.max(0, settings.brightnessVariation)),
                opacityVariation: Math.min(100, Math.max(0, settings.opacityVariation)),
                pressureVariation: Math.min(100, Math.max(0, settings.pressureVariation)),
                grayVariation: Math.min(100, Math.max(0, settings.grayVariation || 0)),
                calculationMode: settings.calculationMode || 'absolute'
            };

            // Âè™‰øùÂ≠òËÆæÁΩÆÔºå‰∏çÂÖ≥Èó≠Èù¢Êùø
            this.setState({
                colorSettings: validatedSettings
            });
        } catch (error) {
            console.error('‰øùÂ≠òÈ¢úËâ≤ËÆæÁΩÆÂ§±Ë¥•:', error);
            // ÂèØ‰ª•Ê∑ªÂä†ÈîôËØØÊèêÁ§∫UI
        }
    }

    handlePatternSelect(pattern: Pattern) {
        this.setState({
            selectedPattern: pattern
        });
    }

    handleGradientSelect(gradient: Gradient | null) {
        this.setState({
            selectedGradient: gradient
        });
    }

    closeColorSettings() {
        this.setState({ isColorSettingsOpen: false });
    }

    closePatternPicker() {
        this.setState({ isPatternPickerOpen: false });
    }

    closeGradientPicker() {
        this.setState({ isGradientPickerOpen: false });
    }

    closeStrokeSetting() {
        this.setState({ isStrokeSettingOpen: false });
    }

    async handleSelectionChange(event?: any) {
        if (!this.state.isEnabled || this.isListenerPaused) return;
        // Ê£ÄÊü•‰∫ã‰ª∂‰∏≠ÊòØÂê¶ÂåÖÂê´featherÈ°πÔºåÂ¶ÇÊûúÂåÖÂê´ÂàôÁõ¥Êé•ËøîÂõû
        if (event && event.feather) {
            return;
        }    

        try {
            const doc = app.activeDocument;
            if (!doc) {
                return;
            }

            // Ê£ÄÊµãÂø´ÈÄüËíôÁâàÁä∂ÊÄÅ
            const isInQuickMask = doc.quickMaskMode;
            if (this.state.isInQuickMask !== isInQuickMask) {
                this.setState({ isInQuickMask });
            }
   
            await new Promise(resolve => setTimeout(resolve, 50));
            const selection = await this.getSelection();
            if (!selection) {
                console.warn('‚ö†Ô∏è ÈÄâÂå∫‰∏∫Á©∫ÔºåË∑≥ËøáÂ°´ÂÖÖ');
                return;
            }

            // ÊöÇÂÅúÁõëÂê¨
            this.isListenerPaused = true;

            await core.executeAsModal(async () => {
                if (this.state.autoUpdateHistory) { await this.setHistoryBrushSource(); }
                // Âè™ÊúâÂΩìÈÄâÂå∫ÈÄâÈ°πÂÄº‰∏ç‰∏∫ÂàùÂßãÂÄºÊó∂ÊâçÊâßË°åÈÄâÊã©Âπ∂ÈÅÆ‰Ωè
                const options: SelectionOptions = {
                    selectionSmooth: this.state.selectionSmooth,
                    selectionContrast: this.state.selectionContrast,
                    selectionExpand: this.state.selectionExpand
                };
                
                if (SelectionHandler.shouldApplySelectionModification(options)) {
                    await this.applySelectionModification();
                }
                await this.applyFeather();
                const fillSuccess = await this.fillSelection();
                if (this.state.strokeEnabled && fillSuccess) {
                    // Ëé∑ÂèñÂõæÂ±Ç‰ø°ÊÅØ
                    const layerInfo = await LayerInfoHandler.getActiveLayerInfo();
                    await strokeSelection(this.state, layerInfo);
                }
                if (this.state.deselectAfterFill) {
                    await this.deselectSelection();
                }
            }, { commandName: 'Ê≠£Âú®Â§ÑÁêÜÈÄâÂå∫‰∏≠......' });

            // ÊÅ¢Â§çÁõëÂê¨
            this.isListenerPaused = false;
        } catch (error) {
            console.error('‚ùå Â§ÑÁêÜÂ§±Ë¥•:', error);
            // Á°Æ‰øùÂú®ÈîôËØØÊÉÖÂÜµ‰∏ã‰πüÊÅ¢Â§çÁõëÂê¨
            this.isListenerPaused = false;
        }
    }

    async getSelection() {
        try {
            const result = await action.batchPlay(
                [
                    {
                        _obj: 'get',
                        _target: [
                            { _property: 'selection' },
                            { _ref: 'document', _enum: 'ordinal', _value: 'targetEnum' },
                        ],
                    },
                ],
                { synchronousExecution: true }
            );
            if (result && result.length > 0 && result[0].selection) {
                return result[0].selection;
            } else {
                return null;
            }
        } catch (error) {
            console.error('‚ùå Ëé∑ÂèñÈÄâÂå∫Â§±Ë¥•:', error);
            return null;
        }
    }

    async setHistoryBrushSource() {
        const doc = app.activeDocument;
        if (!doc) {
            console.warn('‚ö†Ô∏è Ê≤°ÊúâÊâìÂºÄÁöÑÊñáÊ°£ÔºåË∑≥ËøáÊõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïÁîªÁ¨îÊ∫ê');
            return;
        }

        const historyStates = doc.historyStates;
        if (historyStates.length === 0) {
            console.warn('‚ö†Ô∏è ÂéÜÂè≤ËÆ∞ÂΩïÂ†ÜÊ†à‰∏∫Á©∫ÔºåË∑≥ËøáÊõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïÁîªÁ¨îÊ∫ê');
            return;
        }

        try {
            await action.batchPlay(
                [
                    {
                        _obj: 'set',
                        _target: [
                            {
                                _ref: 'historyState',
                                _property: 'historyBrushSource'
                            }
                        ],
                        to: {
                             _ref: "historyState",
                            _property: "currentHistoryState"
                        },
                        _options: {
                            dialogOptions: 'dontDisplay'
                        }
                    }
                ],
                {}
            );
        } catch (error) {
            console.error(error);
        }  
    }

    async applyFeather() {
        const featherAmount = Number(this.state.feather);
        if (featherAmount < 0) return;
        
        // ÂΩìÁæΩÂåñÂÄº‰∏∫0Êó∂ÔºåË∑≥ËøáÁæΩÂåñÊìç‰Ωú
        if (featherAmount === 0) {
            // Áõ¥Êé•Êõ¥Êñ∞ÈÄâÂå∫Áä∂ÊÄÅÔºå‰∏çÊâßË°åÁæΩÂåñ
            const newSelection = await this.getSelection();
            this.setState({ SelectionA: newSelection });
            return;
        }
        
        await action.batchPlay(
            [
                {
                    _obj: 'feather',
                    radius: featherAmount,
                    _isCommand: true
                },
            ],
            { synchronousExecution: true, modalBehavior: 'execute' }
        );
        
        await new Promise(resolve => setTimeout(resolve, 50));
        const newSelection = await this.getSelection();
        this.setState({ SelectionA: newSelection });
    }

     // ‰øÆÊîπÊñ∞Âª∫ÂõæÂ±ÇÊ®°ÂºèÂàáÊç¢ÂáΩÊï∞
     toggleCreateNewLayer() {
        this.setState(prevState => ({
            createNewLayer: !prevState.createNewLayer,
            clearMode: prevState.createNewLayer ? prevState.clearMode : false 
        }));
    }

    async fillSelection() {
        await new Promise(resolve => setTimeout(resolve, 50));
        try {
            // ÊéàÊùÉÈó®ÊéßÔºöÊú™ÊéàÊùÉ‰∏îÈùûËØïÁî®ÔºåÊâìÂºÄÊéàÊùÉÁ™óÂè£Âπ∂ÈòªÊ≠¢ÂäüËÉΩ
            if (!this.state.isLicensed && !this.state.isTrial) {
                this.setState({ isLicenseDialogOpen: true });
                return false;
            }

            // Ê£ÄÊü•ÊòØÂê¶Âú®ÂçïÈÄöÈÅìÊ®°Âºè
            const isInSingleChannel = await LayerInfoHandler.checkSingleColorChannelMode();
            if (isInSingleChannel) {
                
                const fillOptions = {
                    opacity: this.state.opacity,
                    blendMode: this.state.blendMode,
                    pattern: this.state.selectedPattern,
                    gradient: this.state.selectedGradient
                };
                
                if (this.state.clearMode) {
                    const ok = await SingleChannelHandler.clearSingleChannel(fillOptions, this.state.fillMode, this.state);
                    return ok === undefined ? true : !!ok; // Ëã•ÂÜÖÈÉ®Êú™ÊòæÂºèËøîÂõûÔºåËßÜ‰∏∫ÊàêÂäü
                } else {
                    const ok = await SingleChannelHandler.fillSingleChannel(fillOptions, this.state.fillMode, this.state);
                    return ok === undefined ? true : !!ok;
                }
            }

            const layerInfo = await LayerInfoHandler.getActiveLayerInfo();
            if (!layerInfo) return false;

            if (this.state.clearMode) {
                const layerInfo = await LayerInfoHandler.getActiveLayerInfo();
                await ClearHandler.clearWithOpacity(this.state.opacity, this.state, layerInfo);
                return true;
            }
    
            if (this.state.createNewLayer) {
                await action.batchPlay(
                    [{
                        _obj: "make",
                        _target: [{ _ref: "layer" }],
                        using: {
                            _obj: "layer",
                            mode: {
                                _enum: "blendMode",
                                _value: BLEND_MODES[this.state.blendMode] || "normal"
                            }
                        },
                        _options: { dialogOptions: "dontDisplay" }
                    }],
                    { synchronousExecution: true }
                );
            }
    
            const { isBackground, hasTransparencyLocked, hasPixels } = layerInfo;
    
            if (this.state.fillMode === 'pattern') {
                if (this.state.selectedPattern) {
                    await PatternFill.fillPattern({
                        opacity: this.state.opacity,
                        blendMode: this.state.blendMode,
                        pattern: this.state.selectedPattern,
                        preserveTransparency: this.state.selectedPattern.preserveTransparency
                    }, layerInfo, this.state);
                    return true;
                } else {
                    // Áº∫Â∞ëÂõæÊ°àÈ¢ÑËÆæÔºåÊòæÁ§∫Ë≠¶ÂëäÂπ∂Ë∑≥ËøáÂ°´ÂÖÖ
                    await core.showAlert({ message: 'ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™ÂõæÊ°àÈ¢ÑËÆæ' });
                    return false;
                }
            } else if (this.state.fillMode === 'gradient') {
                if (this.state.selectedGradient) {
                    await GradientFill.fillGradient({
                        opacity: this.state.opacity,
                        blendMode: this.state.blendMode,
                        gradient: this.state.selectedGradient,
                        preserveTransparency: this.state.selectedGradient.preserveTransparency
                    }, layerInfo, this.state);
                    return true;
                } else {
                    // Áº∫Â∞ëÊ∏êÂèòÈ¢ÑËÆæÔºåÊòæÁ§∫Ë≠¶ÂëäÂπ∂Ë∑≥ËøáÂ°´ÂÖÖ
                    await core.showAlert({ message: 'ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Ê∏êÂèòÈ¢ÑËÆæ' });
                    return false; 
                } 
            } else {
                // Ê£ÄÊµãÊòØÂê¶Âú®Âø´ÈÄüËíôÁâàÁä∂ÊÄÅ
                const isInQuickMask = layerInfo.isInQuickMask;
                const randomColor = calculateRandomColor(this.state.colorSettings, this.state.opacity, undefined, isInQuickMask);
                
                // Âè™ÊúâÂú®Âø´ÈÄüËíôÁâàÁä∂ÊÄÅ‰∏î‰∏∫selectedAreasÊ®°ÂºèÊó∂ÔºåÊâçÂèçËΩ¨ÁÅ∞Â∫¶ÂÄº
                let finalColor = randomColor;
                if (isInQuickMask) {
                    // Ëé∑ÂèñÂø´ÈÄüËíôÁâàÁöÑisSelectedAreasÂ±ûÊÄß
                    try {
                        const channelResult = await action.batchPlay([
                            {
                                _obj: "get",
                                _target: [
                                    {
                                        _ref: "channel",
                                        _name: "Âø´ÈÄüËíôÁâà"
                                    }
                                ]
                            }
                        ], { synchronousExecution: true });
                        
                        let isSelectedAreas = false;
                        if (channelResult[0] && 
                            channelResult[0].alphaChannelOptions && 
                            channelResult[0].alphaChannelOptions.colorIndicates) {
                            isSelectedAreas = channelResult[0].alphaChannelOptions.colorIndicates._value === "selectedAreas";
                        }
                        
                        // Âè™ÊúâÂú®selectedAreasÊ®°Âºè‰∏ãÊâçÂèçËΩ¨ÁÅ∞Â∫¶ÂÄº
                        if (isSelectedAreas) {
                            // Â∞ÜHSBËΩ¨Êç¢‰∏∫RGBÔºåËÆ°ÁÆóÁÅ∞Â∫¶ÂÄºÔºåÁÑ∂ÂêéÂèçËΩ¨
                            const rgb = hsbToRgb(randomColor.hsb.hue, randomColor.hsb.saturation, randomColor.hsb.brightness);
                            const originalGrayValue = rgbToGray(rgb.red, rgb.green, rgb.blue);
                            const invertedGrayValue = 255 - originalGrayValue;
                            
                            // Â∞ÜÂèçËΩ¨ÂêéÁöÑÁÅ∞Â∫¶ÂÄºËΩ¨Êç¢ÂõûHSBÔºà‰∫ÆÂ∫¶ÂÄºÔºâ
                            const invertedBrightness = (invertedGrayValue / 255) * 100;
                            
                            finalColor = {
                                ...randomColor,
                                hsb: {
                                    ...randomColor.hsb,
                                    brightness: invertedBrightness
                                }
                            };
                        }
                    } catch (error) {
                        console.error('Ëé∑ÂèñÂø´ÈÄüËíôÁâàÂ±ûÊÄßÂ§±Ë¥•:', error);
                    }
                }
                
                const fillOptions = {
                    opacity: finalColor.opacity,
                    blendMode: this.state.blendMode,
                    color: finalColor
                };

                // Êõ¥Êñ∞Â°´ÂÖÖÂëΩ‰ª§‰ª•‰ΩøÁî®ÈöèÊú∫È¢úËâ≤
                const command = FillHandler.createColorFillCommand(fillOptions);
    
                if (isBackground) {
                    await FillHandler.fillBackground(fillOptions);
                } 
                else if (hasTransparencyLocked && hasPixels) {
                    await FillHandler.fillLockedWithPixels(fillOptions);
                } 
                else if (hasTransparencyLocked && !hasPixels) {
                    await FillHandler.fillLockedWithoutPixels(
                        fillOptions,
                        () => this.unlockLayerTransparency(),
                        () => this.lockLayerTransparency()
                    );
                } 
                else if (!hasTransparencyLocked && !isBackground) {
                    await FillHandler.fillUnlocked(fillOptions);
                }
                else {
                    await FillHandler.fillBackground(fillOptions);
                }
                return true;
            }
        } catch (error) {
            console.error('Â°´ÂÖÖÈÄâÂå∫Â§±Ë¥•:', error);
            return false;
        }
    }

    // ËÆæÁΩÆÂõæÂ±ÇÈÄèÊòéÂ∫¶ÈîÅÂÆö
    async lockLayerTransparency() {
        try {
            await action.batchPlay([
                {
                    _obj: "applyLocking",
                    _target: [
                        { _ref: "layer", _enum: "ordinal", _value: "targetEnum" }
                    ],
                    layerLocking: {
                        _obj: "layerLocking",
                        protectTransparency: true
                    },
                    _options: { dialogOptions: "dontDisplay" }
                }
            ], { synchronousExecution: true });
        } catch (error) {}
    }

    // ËÆæÁΩÆÂõæÂ±ÇÈÄèÊòéÂ∫¶‰∏çÈîÅÂÆö
    async unlockLayerTransparency() {
        try {
            await action.batchPlay([
                {
                    _obj: "applyLocking",
                    _target: [
                        { _ref: "layer", _enum: "ordinal", _value: "targetEnum" }
                    ],
                    layerLocking: {
                        _obj: "layerLocking",
                        protectNone: true
                    },
                    _options: { dialogOptions: "dontDisplay" }
                }
            ], { synchronousExecution: true });
        } catch (error) {}
    }

    async deselectSelection() {
        await action.batchPlay([
           {
            _obj: "set",
            _target: [
               {
                  _ref: "channel",
                  _property: "selection"
               }
            ],
            to: {
               _enum: "ordinal",
               _value: "none"
            },
            _options: {
               dialogOptions: "dontDisplay"
            }
         }
        ], { synchronousExecution: true, dialogOptions: 'dontDisplayDialogs' });
    }

    // Â§ÑÁêÜÊ†áÁ≠æÈº†Ê†áÊåâ‰∏ã‰∫ã‰ª∂
    handleLabelMouseDown(event, target) {
        if (!this || !this.state) return;
        event.preventDefault();
        this.setState({
            isDragging: true,
            dragStartX: event.clientX,
            dragStartValue: this.state[target],
            dragTarget: target
        });
    }

    // Â§ÑÁêÜÈº†Ê†áÁßªÂä®‰∫ã‰ª∂
    handleMouseMove(event: MouseEvent): void {
        if (!this.state || !this.state.isDragging || !this.state.dragTarget) return;
        
        const newValue = DragHandler.calculateNewValue(
            this.state.dragTarget,
            this.state.dragStartValue,
            this.state.dragStartX,
            event.clientX
        );
        
        this.setState({ [this.state.dragTarget]: newValue });
    }

    // Â§ÑÁêÜÈº†Ê†áÈáäÊîæ‰∫ã‰ª∂
    handleMouseUp(): void {
        if (!this || !this.state) return;
        this.setState({ isDragging: false });
    }

    handleOpacityChange(event) {
        this.setState({ opacity: parseInt(event.target.value, 10) });
    }

    handleFeatherChange(event) {
        this.setState({ feather: parseInt(event.target.value, 10) });
    }

    handleBlendModeChange(event) {
        const newBlendMode = event.target.value;
        this.setState({ blendMode: newBlendMode });
    }

    toggleAutoUpdateHistory() {
        this.setState({ autoUpdateHistory: !this.state.autoUpdateHistory });
    }
    
    toggleDeselectAfterFill() {
        this.setState({ deselectAfterFill: !this.state.deselectAfterFill });
    }

    // Ê£ÄÊµãËíôÁâàÊ®°ÂºèÁä∂ÊÄÅ
    async checkMaskModes() {
        try {
            const layerInfo = await LayerInfoHandler.getActiveLayerInfo();
            this.isInLayerMask = layerInfo?.isInLayerMask || false;
            this.isInQuickMask = layerInfo?.isInQuickMask || false;
            this.isInSingleColorChannel = layerInfo?.isInSingleColorChannel || false;
        } catch (error) {
            console.error('Ê£ÄÊµãËíôÁâàÊ®°ÂºèÂ§±Ë¥•:', error);
            this.isInLayerMask = false;
            this.isInQuickMask = false;
            this.isInSingleColorChannel = false;
        }
    }

    // Â§ÑÁêÜPhotoshopÈÄöÁü•‰∫ã‰ª∂
    async handleNotification() {
        try {
            // Ê£ÄÊµãÂõæÂ±ÇËíôÁâàÂíåÂø´ÈÄüËíôÁâàÁä∂ÊÄÅ
            await this.checkMaskModes();
            // Âº∫Âà∂ÈáçÊñ∞Ê∏≤Êüì‰ª•Êõ¥Êñ∞È¢úËâ≤È¢ÑËßà
            this.forceUpdate();
        } catch (error) {
            // ÈùôÈªòÂ§ÑÁêÜÈîôËØØÔºåÈÅøÂÖçÈ¢ëÁπÅÁöÑÈîôËØØÊó•Âøó
        }
    }

    // Ëé∑ÂèñÊèèËæπÈ¢úËâ≤È¢ÑËßàÊ†∑Âºè
    getStrokeColorPreviewStyle() {
        const { strokeColor, clearMode } = this.state;
        const shouldShowGray = clearMode || this.isInLayerMask || this.isInQuickMask || this.isInSingleColorChannel;
        
        if (!strokeColor) {
            return { backgroundColor: '#000000' };
        }
        
        if (shouldShowGray) {
            // ‰ΩøÁî®ÁÅ∞Â∫¶ÊòæÁ§∫ÔºöÂ∞ÜRGBËΩ¨Êç¢‰∏∫ÁÅ∞Â∫¶ÂÄº
            const grayValue = Math.round(strokeColor.red * 0.299 + strokeColor.green * 0.587 + strokeColor.blue * 0.114);
            return { backgroundColor: `rgb(${grayValue}, ${grayValue}, ${grayValue})` };
        } else {
            // Ê≠£Â∏∏ÂΩ©Ëâ≤ÊòæÁ§∫
            return { backgroundColor: `rgb(${strokeColor.red}, ${strokeColor.green}, ${strokeColor.blue})` };
        }
    }  

    // ===== ËÆ∏ÂèØËØÅÁõ∏ÂÖ≥ÊñπÊ≥ï =====
    async checkLicenseStatus() {
        try {
            // ÂÖàÊü•ÁúãÊú¨Âú∞ÁºìÂ≠ò
            const status = await LicenseManager.checkLicenseStatus();
            let isLicensed = status.isValid;
            let isTrial = false;
            let trialDaysRemaining = 0;

            // Â¶ÇÊûú‰∏çÊòØÊ≠£ÂºèËÆ∏ÂèØËØÅÔºåÊ£ÄÊü•ÊòØÂê¶Â§Ñ‰∫éËØïÁî®Âπ∂ÊòØÂê¶ËøáÊúü
            if (!isLicensed) {
                const expired = await LicenseManager.isTrialExpired();
                // ËØªÂèñÁºìÂ≠òÁúãÁúãÊòØÂê¶ÊòØËØïÁî®
                const cachedInfo: any = (status && status.info) || await (LicenseManager as any).getCachedLicense?.();
                const isTrialKey = cachedInfo && cachedInfo.key && String(cachedInfo.key).startsWith('TRIAL_');
                isTrial = !!isTrialKey && !expired;

                if (isTrialKey && cachedInfo && cachedInfo.expiryDate) {
                    const expire = new Date(cachedInfo.expiryDate).getTime();
                    const diffDays = Math.max(0, Math.ceil((expire - Date.now()) / (24 * 60 * 60 * 1000)));
                    trialDaysRemaining = diffDays;
                }
            }

            // Ëá™Âä®ÈáçÊñ∞È™åËØÅÔºàÂÆΩÊùæÔºöÂ§±Ë¥•‰∏çÈòªÊ≠¢Ôºâ
            if (status.needsReverification) {
                try { await LicenseManager.autoReverifyIfNeeded(); } catch {}
            }

            // ÊéßÂà∂ÂØπËØùÊ°ÜÊâìÂºÄÈÄªËæëÔºöÈ¶ñÊ¨°ÂêØÂä®Ëã•Êú™ÊéàÊùÉÂàôÊâìÂºÄ
            this.setState({
                isLicensed,
                isTrial,
                trialDaysRemaining,
                isLicenseDialogOpen: !(isLicensed || isTrial)
            });
        } catch (e) {
            console.warn('Ê£ÄÊü•ËÆ∏ÂèØËØÅÁä∂ÊÄÅÂ§±Ë¥•:', e);
            this.setState({ isLicensed: false, isTrial: false, isLicenseDialogOpen: true });
        }
    }

    handleLicenseVerified() {
        this.setState({ isLicensed: true, isTrial: false, isLicenseDialogOpen: false });
        // ÂØπËØùÊ°ÜÂÖ≥Èó≠ÔºåÁßªÈô§Á±ªÂêçÊÅ¢Â§çËæìÂÖ•Ê°Ü
        document.body.classList.remove('license-dialog-open');
    }

    handleTrialStarted() {
        // ËØïÁî®7Â§©
        this.setState({ isLicensed: false, isTrial: true, isLicenseDialogOpen: false, trialDaysRemaining: 7 });
        // ÂØπËØùÊ°ÜÂÖ≥Èó≠ÔºåÁßªÈô§Á±ªÂêçÊÅ¢Â§çËæìÂÖ•Ê°Ü
        document.body.classList.remove('license-dialog-open');
    }

    closeLicenseDialog() {
        this.setState({ isLicenseDialogOpen: false });
        // ÁßªÈô§bodyÁ±ªÂêçÔºåÊÅ¢Â§çËæìÂÖ•Ê°ÜÊòæÁ§∫
        document.body.classList.remove('license-dialog-open');
    }

    // Êñ∞Â¢ûÔºöÊâãÂä®ÊâìÂºÄÊéàÊùÉÂØπËØùÊ°Ü
    openLicenseDialog() {
        this.setState({ isLicenseDialogOpen: true });
        // Ê∑ªÂä†bodyÁ±ªÂêçÔºåÈöêËóèËæìÂÖ•Ê°Ü
        document.body.classList.add('license-dialog-open');
    }

    // ‰∏¥Êó∂Ë∞ÉËØïÊñπÊ≥ïÔºöÈáçÁΩÆËÆ∏ÂèØËØÅÁä∂ÊÄÅ
    async resetLicenseForTesting() {
        try {
            await LicenseManager.clearLicense();
            // ‰πüÊ∏ÖÈô§ËØïÁî®ËÆ∞ÂΩï
            try {
                const localFileSystem = storage.localFileSystem;
                const dataFolder = await localFileSystem.getDataFolder();
                const trialFile = await dataFolder.getEntry('trial.json');
                await trialFile.delete();
            } catch (e) {
                // ËØïÁî®Êñá‰ª∂ÂèØËÉΩ‰∏çÂ≠òÂú®ÔºåÂøΩÁï•ÈîôËØØ
            }
            
            // ÈáçÁΩÆÁä∂ÊÄÅÂπ∂ÊòæÁ§∫ÂØπËØùÊ°Ü
            this.setState({
                isLicensed: false,
                isTrial: false,
                isLicenseDialogOpen: true,
                trialDaysRemaining: 0
            });
            
            console.log('ËÆ∏ÂèØËØÅÁä∂ÊÄÅÂ∑≤ÈáçÁΩÆÔºåÂèØÈáçÊñ∞ÊµãËØïÊéàÊùÉÊµÅÁ®ã');
        } catch (error) {
            console.error('ÈáçÁΩÆËÆ∏ÂèØËØÅÁä∂ÊÄÅÂ§±Ë¥•:', error);
        }
    }

    render() {
        return (
            <div>
                {/* ÊéàÊùÉÂØπËØùÊ°Ü */}
                <LicenseDialog
                    isOpen={this.state.isLicenseDialogOpen}
                    isLicensed={this.state.isLicensed}
                    isTrial={this.state.isTrial}
                    trialDaysRemaining={this.state.trialDaysRemaining}
                    onLicenseVerified={this.handleLicenseVerified}
                    onTrialStarted={this.handleTrialStarted}
                    onClose={this.closeLicenseDialog}
                />
                <div className="container">
                <h3 className="title" 
title={`‚óè ÁîüÊàêÈÄâÂå∫Êó∂ÔºåÊèí‰ª∂‰ºöËá™Âä®Ê†πÊçÆÈÄâÊã©ÁöÑÊ®°ÂºèÂ°´ÂÖÖ/Âà†Èô§ÂÜÖÂÆπ„ÄÇ

‚óè ÈÄâÂå∫Ê®°ÂºèÂè™Êúâ‰Ωú‰∏∫„ÄêÊñ∞ÈÄâÂå∫„ÄëÊó∂ÔºåÊâç‰ºöËß¶ÂèëËá™Âä®Â°´ÂÖÖÔºåÂä†ÈÄâÔºåÂáèÈÄâÔºå‰∫§ÂèâÈÄâÊã©‰∏ç‰ºöËá™Âä®Â°´ÂÖÖ„ÄÇ

‚óè Áî±‰∫éÊ†∏ÂøÉÂäüËÉΩ‰ΩøÁî®‰∫ÜimageAPIÔºåÊâÄÊúâÂíåÊ∏êÂèò‰∏éÂõæÊ°àÁõ∏ÂÖ≥ÁöÑÂäüËÉΩÈúÄË¶ÅËá≥Â∞ëPSÁâàÊú¨24.2ÔºàPS2023Á¨¨‰∫å‰∏™ÁâàÊú¨ÔºâÊâçËÉΩ‰ΩøÁî®„ÄÇ

‚óè Áî±‰∫éÊØèÊ¨°ÁîüÊàêÈÄâÂå∫ÂêéÔºåÊèí‰ª∂‰ºöÁ´ãÂàªÊâßË°åËã•Âπ≤‰∏™Ê≠•È™§„ÄÇÂõ†Ê≠§ÊÉ≥Ë¶ÅÊí§ÈîÄÊú¨Ê¨°ÁöÑËá™Âä®Â°´ÂÖÖÔºåÂª∫ËÆÆÂõûÊ∫ØÂéÜÂè≤ËÆ∞ÂΩï„ÄÇ`
}>
                    <span className="title-text">ÈÄâÂå∫Á¨î1.2</span>
                    {/* ‰∏¥Êó∂Ë∞ÉËØïÔºöÈáçÁΩÆËÆ∏ÂèØËØÅÊåâÈíÆ */}
                    <button
                        onClick={() => this.resetLicenseForTesting()}
                        title="ÈáçÁΩÆËÆ∏ÂèØËØÅÁä∂ÊÄÅÔºà‰ªÖË∞ÉËØïÁî®Ôºâ"
                        style={{
                            position: 'absolute',
                            right: 32,
                            top: 2,
                            width: 20,
                            height: 20,
                            borderRadius: 10,
                            border: '1px solid var(--border-color)',
                            background: 'var(--bg-color)',
                            color: 'red',
                            cursor: 'pointer',
                            lineHeight: '18px',
                            fontSize: '10px',
                            padding: 0,
                            zIndex: 10
                        }}
                    >
                        R
                    </button>
                    {/* Êñ∞Â¢ûÔºöÂ∏ÆÂä©ÊåâÈíÆÔºàÂè≥‰∏äËßíÈóÆÂè∑ÔºâÔºåÁî®‰∫éÈáçÊñ∞ÊâìÂºÄÊéàÊùÉÁ™óÂè£ */}
                    <button
                        onClick={this.openLicenseDialog}
                        title="ÊâìÂºÄËÆ∏ÂèØËØÅ‰∏éËØïÁî®Èù¢Êùø"
                        style={{
                            position: 'absolute',
                            right: 8,
                            top: 2,
                            width: 20,
                            height: 20,
                            borderRadius: 10,
                            border: '1px solid var(--border-color)',
                            background: 'var(--bg-color)',
                            color: 'var(--text-color)',
                            cursor: 'pointer',
                            lineHeight: '18px',
                            fontSize: '12px',
                            padding: 0,
                            zIndex: 10
                        }}
                    >
                        ?
                    </button>
                </h3>
                <div className="button-container">
                    <sp-action-button 
                    className="main-button" 
                    onClick={this.handleButtonClick}
title={`‚óè ÂäüËÉΩÂºÄÂêØÂêéÔºåPSÂ∑•ÂÖ∑Ê†èÁæΩÂåñÂèÇÊï∞ËÆæ‰∏∫0Êó∂ÔºåËá™Âä®Â°´ÂÖÖÊâçÂèØÊ≠£Â∏∏‰ΩøÁî®„ÄÇ

‚óè Êé®ËçêÁî±‰∏ãÊñπÁöÑÊèí‰ª∂Èù¢ÊùøËÆæÁΩÆÊÉ≥Ë¶ÅÁöÑÁæΩÂåñÂÄº„ÄÇ

‚óè Â§Ñ‰∫éÂ•óÁ¥¢Á≠âÂ∑•ÂÖ∑Êó∂Ôºå‰æùÊ¨°Êåâ‰∏ã„ÄêEnter ‚Üí Êï∞Â≠ó1 ‚Üí Enter„ÄëÔºåÂèØ‰ª•ÊääÂ∑•ÂÖ∑Ê†èÁöÑÁæΩÂåñÂÄºËÆæ‰∏∫1ÔºåÊöÇÂÅúËá™Âä®Â°´ÂÖÖ„ÄÇ

‚óè ‰æùÊ¨°Êåâ‰∏ã„ÄêEnter ‚Üí Êï∞Â≠ó0 ‚Üí Enter„ÄëÔºåÂèØ‰ª•ÊääÁæΩÂåñÂÄºÊîπÂõû0ÔºåÊÅ¢Â§çËá™Âä®Â°´ÂÖÖ„ÄÇ`
}>
                        <div className="button-content">
                            <span className={`button-text ${!this.state.isEnabled ? 'disabled' : ''}`}>
                                {this.state.isEnabled ? 'ÂäüËÉΩÂºÄÂêØ' : 'ÂäüËÉΩÂÖ≥Èó≠'}
                            </span>
                            <div className={`button-indicator ${this.state.isEnabled ? 'enabled' : 'disabled'}`}></div>
                        </div>
                    </sp-action-button>
                </div>

                <div className="blend-mode-container">
                    <span className={`blend-mode-label ${this.state.clearMode ? 'disabled' : ''}`} 
title={`‚óè Ê∑∑ÂêàÊ®°ÂºèÊîØÊåÅÁ∫ØËâ≤ÔºåÂõæÊ°àÂíåÊ∏êÂèò‰∏âÁßçÊ®°Âºè„ÄÇÊèèËæπÁöÑÊ∑∑ÂêàÊ®°ÂºèÈúÄË¶ÅÂú®ÊèèËæπÁöÑÈù¢Êùø‰∏≠Áã¨Á´ãËÆæÁΩÆ„ÄÇ
  
‚óè Âú®Êñ∞Âª∫ÂõæÂ±ÇÊ®°Âºè‰∏ãÔºöËØ•Ê∑∑ÂêàÊ®°Âºè‰∏ãÊãâËèúÂçï‰øÆÊîπÁöÑÊòØÊñ∞Âª∫ÂõæÂ±ÇÁöÑÊ∑∑ÂêàÊ®°Âºè„ÄÇËá≥‰∫éÊú¨Ê¨°Âú®Êñ∞ÂõæÂ±Ç‰∏≠Â°´ÂÖÖÁöÑÂÜÖÂÆπÔºåÈááÂèñÁöÑÊ∑∑ÂêàÊ®°ÂºèÊòØ„ÄêÊ≠£Â∏∏„Äë„ÄÇ
    
‚óè Âú®Ê∏ÖÈô§Ê®°Âºè‰∏ãÔºöÂºÄÂêØÂêéÈªòËÆ§ËÆæ‰∏∫„ÄêÊ∏ÖÈô§„ÄëÔºåÊ∑∑ÂêàÊ®°Âºè‰∏çÊîØÊåÅ‰øÆÊîπ„ÄÇ`
}>
                    Ê∑∑ÂêàÊ®°ÂºèÔºö
                    </span>

                    <sp-picker
                        size="s"
                        selects="single"
                        selected={this.state.blendMode || "Ê≠£Â∏∏"}
                        onChange={this.handleBlendModeChange}
                        disabled={this.state.clearMode}
                        title="ÈÄâÊã©Â°´ÂÖÖÊó∂‰ΩøÁî®ÁöÑÊ∑∑ÂêàÊ®°ÂºèÔºåËÆ°ÁÆóÊñπÂºè‰∏éPSÂéüÁîü‰∏ÄËá¥„ÄÇ"
                    >
                        <sp-menu>
                            {BLEND_MODE_OPTIONS.map((group, groupIndex) => (
                                <React.Fragment key={groupIndex}>
                                    {group.map((option) => (
                                        <sp-menu-item 
                                            key={option.value} 
                                            value={option.value}
                                            selected={option.value === (this.state.blendMode || "Ê≠£Â∏∏")}
                                        >
                                            {option.label}
                                        </sp-menu-item>
                                    ))}
                                    {groupIndex < BLEND_MODE_OPTIONS.length - 1 && (
                                        <sp-menu-divider />
                                    )}
                                </React.Fragment>
                            ))}
                        </sp-menu>
                    </sp-picker>
                </div> 

                <div className="slider-container">
                    <label
                        className={`slider-label ${
                            this.state.isDragging && this.state.dragTarget === 'opacity' 
                            ? 'dragging' 
                            : 'not-dragging'
                        }`}
                        onMouseDown={(e) => this.handleLabelMouseDown(e, 'opacity')}
title={`‚óè Ë∞ÉÊï¥Â°´ÂÖÖÂÜÖÂÆπÁöÑ‰∏çÈÄèÊòéÂ∫¶Ôºå‰∏çÈÄèÊòéÂ∫¶Èó¥ÈááÁî®„Äê‰πòÁÆó„Äë„ÄÇ
    
‚óè Âú®Â°´ÂÖÖÊ®°Âºè‰∏ãÔºöÂÅáËÆæÂéüÊú¨Â°´ÂÖÖÁöÑÂõæÊ°à‰∏≠Êúâ‰∏Ä‰∏™Ëá™Â∏¶50%ÁöÑ‰∏çÈÄèÊòéÂ∫¶ÁöÑÂå∫ÂüüÔºåÊèí‰ª∂Èù¢Êùø‰∏≠‰∏çÈÄèÊòéÂ∫¶ËÆæ‰∏∫50%ÔºåÂàôÊúÄÁªàÂ°´ÂÖÖËØ•Âå∫ÂüüÁöÑ‰∏çÈÄèÊòéÂ∫¶‰∏∫50%*50%*ÔºàÂèóÁæΩÂåñÂΩ±Âìç‰∫ßÁîüÁöÑ‰∏çÈÄèÊòéÂ∫¶Ôºâ„ÄÇ

‚óè Âú®Ê∏ÖÈô§Ê®°Âºè‰∏ãÔºö‰∏çÈÄèÊòéÂ∫¶ËÆ°ÁÆóÊñπÂºè‰∏éÂ°´ÂÖÖÊ®°ÂºèÁõ∏Âêå„ÄÇ

‚óè Âú®Êñ∞Âª∫ÂõæÂ±ÇÊ®°Âºè‰∏ãÔºöÂΩ±ÂìçÁöÑÊòØÊñ∞ÂõæÂ±ÇÁöÑ‰∏çÈÄèÊòéÂ∫¶ÔºåÂÅáËÆæÂ°´ÂÖÖÁöÑÂõæÊ°àÊàñËÄÖÊ∏êÂèòÂéüÂÖàÂ∏¶Êúâ‰∏çÈÄèÊòéÂ∫¶ÔºåÂ°´ÂÖÖÁöÑÂÜÖÂÆπ‰ªç‰øùÊåÅÂéüÊù•ÁöÑ‰∏çÈÄèÊòéÂ∫¶„ÄÇ`
}>
                    ‰∏çÈÄèÊòéÂ∫¶
                    
                    <div style={{ display: 'flex', alignItems: 'center' }}>
                    <input
                        type="number"
                        min="0"
                        max="100"
                        value={this.state.opacity}
                        onChange={(e) => this.setState({ opacity: Number(e.target.value) })}
                        style={{ width: '30px', zIndex: 1 }}
                        title="ËæìÂÖ•Â°´ÂÖÖÂÜÖÂÆπÁöÑ‰∏çÈÄèÊòéÂ∫¶Ôºà0-100Ôºâ„ÄÇ"
                    />
                    <span style={{ fontSize: '13px' }}>%</span>
                    </div>

                    </label>
                    <input
                        type='range'
                        min='0'
                        max='100'
                        step='1'
                        value={this.state.opacity}
                        onChange={this.handleOpacityChange}
                        className="slider-input"
                        title="Ë∞ÉÊï¥Â°´ÂÖÖÁöÑ‰∏çÈÄèÊòéÂ∫¶Ôºå0%‰∏∫ÂÆåÂÖ®ÈÄèÊòéÔºå100%‰∏∫ÂÆåÂÖ®‰∏çÈÄèÊòé„ÄÇ"
                    />
                    
                    <label
                        className={`slider-label ${
                            this.state.isDragging && this.state.dragTarget === 'feather' 
                            ? 'dragging' 
                            : 'not-dragging'
                        }`}
                        onMouseDown={(e) => this.handleLabelMouseDown(e, 'feather')}
title={`‚óè ÊîπÈÄ†ÈÄâÂå∫‰ΩøÁî®ÁöÑÁæΩÂåñÂÄºÔºå‰πüÂ∞±ÊòØÂØπÈÄâÂå∫ÁöÑÁÅ∞Â∫¶ÈÄöÈÅì‰ΩøÁî®‰∫ÜÈ´òÊñØÊ®°Á≥ä„ÄÇ

‚óè ÁæΩÂåñÂÄºË∂äÂ§ßÔºåÈÄâÂå∫ËæπÁºòË∂äÊüîÂíåÔºåÂ°´ÂÖÖÂÜÖÂÆπÁöÑ‰∏çÈÄèÊòéÂ∫¶‰πü‰ºöÁõ∏Â∫îÈôç‰Ωé„ÄÇ

‚óè ÁæΩÂåñÂÄº‰πü‰ºöÁõ¥Êé•ÂΩ±ÂìçÊèèËæπÁöÑÁæΩÂåñÁ®ãÂ∫¶‰∏é‰∏çÈÄèÊòéÂ∫¶„ÄÇ`
}>
                        ÁæΩÂåñ

                    <div style={{ display: 'flex', alignItems: 'center' }}>
                    <input
                        type="number"
                        min="0"
                        max="20"
                        value={this.state.feather}
                        onChange={(e) => this.setState({ feather: Number(e.target.value) })}
                        style={{ width: '30px', zIndex: 1 }}
                        title="ËæìÂÖ•ÊîπÈÄ†ÈÄâÂå∫‰ΩøÁî®ÁöÑÁæΩÂåñÂÄºÔºà0-20ÂÉèÁ¥†Ôºâ„ÄÇ"
                        />
                    <span style={{ fontSize: '13px' }}>px</span>
                    </div>

                    </label>
                    <input
                        type='range'
                        min='0'
                        max='20'
                        step='0.5'
                        value={this.state.feather}
                        onChange={this.handleFeatherChange}
                        className="slider-input"
                        title="Ë∞ÉÊï¥ÈÄâÂå∫ËæπÁºòÁöÑÁæΩÂåñÁ®ãÂ∫¶ÔºåÊï∞ÂÄºË∂äÂ§ßËæπÁºòË∂äÊüîÂíå„ÄÇ"
                    />
                </div>
            </div>

 {/* Êñ∞Â¢ûÈÄâÂå∫ÈÄâÈ°πÂå∫Âüü */}
            <div className="expand-section">
                            <div className="expand-header" onClick={this.toggleSelectionOptions} title="ÁÇπÂáªÂ±ïÂºÄ/ÊäòÂè†ÈÄâÂå∫ÈÄâÈ°πËÆæÁΩÆ„ÄÇ">

                                <div className={`expand-icon ${this.state.isSelectionOptionsExpanded ? 'expanded' : ''}`}>
                                    <ExpandIcon expanded={this.state.isSelectionOptionsExpanded} />
                                </div>
                                <span>ÈÄâÂå∫ÈÄâÈ°π</span>
                            </div>
                            <div className={`expand-content ${this.state.isSelectionOptionsExpanded ? 'expanded' : ''}`}>
                                <div className="selection-slider-container">
                                <div className="selection-slider-item">
                                    <label
                                        className={`selection-slider-label ${
                                            this.state.isDragging && this.state.dragTarget === 'selectionSmooth' 
                                            ? 'dragging' 
                                            : 'not-dragging'
                                        }`}
                                        onMouseDown={(e) => this.handleLabelMouseDown(e, 'selectionSmooth')}
title={`‚óè Âú®Â°´ÂÖÖÂâçÔºå‰ª•Èôç‰ΩéÈÄâÂå∫ÁÅ∞Â∫¶ÈÄöÈÅì‰∏≠ÁöÑÈ´òÈ¢ë‰ø°ÊÅØÁöÑÊñπÂºè‰øÆÊîπÈÄâÂå∫„ÄÇ
    
‚óè ÂÖ∑‰ΩìÂÆûÁé∞ÊòØÁõ¥Êé•Êå™Áî®„ÄêÈÄâÊã©Âπ∂ÈÅÆ‰Ωè„Äë‰∏≠ÁöÑÂπ≥ÊªëÈÄâÂå∫ËæπÁºòÂäüËÉΩÔºåÂáèÂ∞èÈÄâÂå∫ËæπÁºòÁöÑÈîØÈΩø‰∏éËµ∑‰ºè„ÄÇ
    
‚óè ÂΩìËØ•ÂÄºËÆæ‰∏∫0Êó∂Ôºå‰∏ç‰ºö‰øÆÊîπÈÄâÂå∫ÔºåÂèØ‰ª•ÊòæËëóÊèêÈ´òËøûÁª≠Ëá™Âä®Â°´ÂÖÖÁöÑÊµÅÁïÖÂ∫¶„ÄÇ`
}>
                                        Âπ≥Êªë
                                    </label>
                                    <input
                                        type='range'
                                        min='0'
                                        max='100'
                                        step='1'
                                        value={this.state.selectionSmooth}
                                        onChange={this.handleSelectionSmoothChange}
                                        className="selection-slider-input"
                                        title="Âπ≥ÊªëÈÄâÂå∫ËæπÁºòÔºåÂáèÂ∞ëÂáπÂá∏Ëµ∑‰ºèÔºåÊï∞ÂÄºË∂äÂ§ßÂπ≥ÊªëÊïàÊûúË∂äÊòéÊòæ„ÄÇ"
                                    />
                                    <div style={{ display: 'flex', alignItems: 'center'}}>
                                        <input
                                            type="number"
                                            min="0"
                                            max="100"
                                            value={this.state.selectionSmooth}
                                            onChange={(e) => this.setState({ selectionSmooth: Number(e.target.value) })}
                                            style={{ marginLeft: '-10px', width: '30px', zIndex: 1 }}
                                            title="Áõ¥Êé•ËæìÂÖ•Âπ≥ÊªëÊï∞ÂÄºÔºà0-100%Ôºâ„ÄÇ"
                                        />
                                        <span style={{ fontSize: '13px' }}>%</span>
                                    </div>
                                    </div>
                            
                                    <div className="selection-slider-item">
                                    <label
                                        className={`selection-slider-label ${
                                            this.state.isDragging && this.state.dragTarget === 'selectionContrast' 
                                            ? 'dragging' 
                                            : 'not-dragging'
                                        }`}
                                        onMouseDown={(e) => this.handleLabelMouseDown(e, 'selectionContrast')}
title={`‚óè Âú®Â°´ÂÖÖÂâçÔºå‰ª•ÈîêÂåñÈÄâÂå∫ÁÅ∞Â∫¶ÈÄöÈÅìÊñπÂºè‰øÆÊîπÈÄâÂå∫„ÄÇ

‚óè ÂÖ∑‰ΩìÂÆûÁé∞ÊòØÁõ¥Êé•Êå™Áî®„ÄêÈÄâÊã©Âπ∂ÈÅÆ‰Ωè„Äë‰∏≠ÁöÑÈîêÂåñÈÄâÂå∫ËæπÁºòÂäüËÉΩÔºåÂ¢ûÂº∫ÈÄâÂå∫ËæπÁºòÁöÑÈîêÂ∫¶„ÄÇ

‚óè ÂΩìËØ•ÂÄºËÆæ‰∏∫0Êó∂Ôºå‰∏ç‰ºö‰øÆÊîπÈÄâÂå∫ÔºåÂèØ‰ª•ÊòæËëóÊèêÈ´òËøûÁª≠Ëá™Âä®Â°´ÂÖÖÁöÑÊµÅÁïÖÂ∫¶„ÄÇ`
}>
                                        ÈîêÂ∫¶

                                    </label>
                                    <input
                                        type='range'
                                        min='0'
                                        max='100'
                                        step='1'
                                        value={this.state.selectionContrast}
                                        onChange={this.handleSelectionContrastChange}
                                        className="selection-slider-input"
                                        title="Â¢ûÂº∫ÈÄâÂå∫ËæπÁºòÁöÑÈîêÂ∫¶Ôºå‰ΩøËæπÁºòÊõ¥Âä†Ê∏ÖÊô∞ÊòéÁ°Æ„ÄÇ"
                                    />
                                    <div style={{ display: 'flex', alignItems: 'center'}}>
                                        <input
                                            type="number"
                                            min="0"
                                            max="100"
                                            value={this.state.selectionContrast}
                                            onChange={(e) => this.setState({ selectionContrast: Number(e.target.value) })}
                                            style={{ marginLeft: '-10px', width: '30px', zIndex: 1 }}
                                            title="Áõ¥Êé•ËæìÂÖ•ÈîêÂ∫¶Êï∞ÂÄºÔºà0-100%Ôºâ„ÄÇ"
                                        />
                                        <span style={{ fontSize: '13px' }}>%</span>
                                    </div>
                                    </div>

                                    <div className="selection-slider-item">
                                    <label
                                        className={`selection-slider-label ${
                                            this.state.isDragging && this.state.dragTarget === 'selectionExpand' 
                                            ? 'dragging' 
                                            : 'not-dragging'
                                        }`}
                                        onMouseDown={(e) => this.handleLabelMouseDown(e, 'selectionExpand')}
title={`‚óè ÂèÇËÄÉPSÊª§ÈïúÂ∫ì‰∏≠Êï∞Ê¨°Âè†Âä†Âñ∑Ê∫ÖÁöÑÁÆóÊ≥ïÔºå‰ª•Âñ∑Ê∫ÖÁöÑÊñπÂºèÊâ©Â±ïÈÄâÂå∫ËåÉÂõ¥„ÄÇ

‚óè Êú™Êù•ÊâìÁÆóÊâ©Â±ïÊõ¥Â§öÁöÑÂèÇÊï∞Ôºå‰ª•ÂØπÈÄâÂå∫ËøõË°åÊõ¥‰∏∞ÂØåÁöÑÊîπÈÄ†„ÄÇ`
}>
                                        Êâ©Êï£
                                    </label>
                                    <input
                                        type='range'
                                        min='0'
                                        max='100'
                                        step='1'
                                        value={this.state.selectionExpand}
                                        onChange={this.handleSelectionExpandChange}
                                        className="selection-slider-input"
                                        title="‰ª•Âñ∑Ê∫ÖÁöÑÊñπÂºèÊîπÈÄ†ÈÄâÂå∫ÔºåÊï∞ÂÄºË∂äÂ§ßÈÄâÂå∫ÂêëÂ§ñÂñ∑Ê∫ÖÁöÑÂº∫Â∫¶Ë∂äÈ´ò„ÄÇ"
                                    />
                                    <div style={{ display: 'flex', alignItems: 'center'}}>
                                        <input
                                            type="number"
                                            min="0"
                                            max="100"
                                            value={this.state.selectionExpand}
                                            onChange={(e) => this.setState({ selectionExpand: Number(e.target.value) })}
                                            style={{ marginLeft: '-10px', width: '30px', zIndex: 1 }}
                                            title="Áõ¥Êé•ËæìÂÖ•Êâ©Êï£Êï∞ÂÄºÔºà0-100%Ôºâ„ÄÇ"
                                        />
                                       <span style={{ fontSize: '13px' }}>%</span>
                                    </div>
                                    </div>
                                </div>
                            </div>
                        </div>


            <div className="expand-section">
                    <div className="expand-header" onClick={this.toggleExpand} title="ÁÇπÂáªÂ±ïÂºÄ/ÊäòÂè†Â°´ÂÖÖÈÄâÈ°πËÆæÁΩÆ„ÄÇ">
                        <div className={`expand-icon ${this.state.isExpanded ? 'expanded' : ''}`}>
                            <ExpandIcon expanded={this.state.isExpanded} />
                        </div>
                        <span>Â°´ÂÖÖÈÄâÈ°π</span>
                    </div>
                    <div className={`expand-content ${this.state.isExpanded ? 'expanded' : ''}`}>


                        {/* Êñ∞Âª∫ÂõæÂ±ÇÂºÄÂÖ≥ */}
                        <div className="switch-container">
                            <span className="switch-label" 
title={`‚óè ÊØèÊ¨°Â°´ÂÖÖÂâçÈÉΩ‰ºö‰ª•ËÆæÁΩÆÁöÑÂèÇÊï∞Êñ∞Âª∫‰∏Ä‰∏™ÂõæÂ±ÇÔºåÂú®ËØ•Êñ∞ÂõæÂ±Ç‰∏äÂ°´ÂÖÖÂÜÖÂÆπ„ÄÇ

‚óè Êñ∞Âª∫ÂõæÂ±ÇÊ®°Âºè‰∏éÊ∏ÖÈô§Ê®°Âºè‰∫íÊñ•Ôºå‰∏çËÉΩÂêåÊó∂ÂºÄÂêØ„ÄÇ`
}>
                            Êñ∞Âª∫ÂõæÂ±Ç
                            </span>
                            <sp-switch 
                                checked={this.state.createNewLayer}
                                onChange={this.toggleCreateNewLayer}
                                disabled={this.state.clearMode || this.state.isInQuickMask}
                                title="ÂºÄÂêØÂêéÂú®Êñ∞ÂõæÂ±Ç‰∏äËøõË°åÂ°´ÂÖÖÔºå‰øùÊåÅ‰∏ãÊñπÂõæÂ±Ç‰∏çÂèóÂΩ±Âìç„ÄÇ"
                            />
                        </div>

                       {/* ÊèèËæπÊ®°ÂºèÂºÄÂÖ≥ */}
                       <div className="switch-container">
                            <label className="switch-label" title="Âú®Â°´ÂÖÖÂêéËá™Âä®‰∏∫ÈÄâÂå∫ËæπÁºòÂ¢ûÂä†ÊèèËæπÊïàÊûú„ÄÇÂºÄÂêØÂè≥‰æßÂºÄÂÖ≥ÂêéÔºåÂ∞Ü‰ºöÊòæÁ§∫ËÆæÁΩÆÊèèËæπÈ¢úËâ≤ÂíåËÆæÁΩÆÂÖ∑‰ΩìÊèèËæπÁöÑÂèÇÊï∞ÁöÑÂå∫Âüü„ÄÇ">ÊèèËæπÊ®°Âºè</label>
                            {this.state.strokeEnabled && (
                                <div className="stroke-color-group">
                                <div 
                                    className="stroke-color-preview"
                                    style={this.getStrokeColorPreviewStyle()}
                                    title="ÁÇπÂáªÈÄâÊã©ÊèèËæπÈ¢úËâ≤ÔºåÂú®ÁºñËæëËíôÁâàÁ≠âÁÅ∞Â∫¶ÈÄöÈÅìÊó∂ÔºåËøôÈáåÂ∞Ü‰ºöÊòæÁ§∫ÈÄâ‰∏≠È¢úËâ≤ÁöÑÁÅ∞Â∫¶„ÄÇ"
                                    onClick={async () => {
                                        try {
                                            // 1. ‰øùÂ≠òÂΩìÂâçÂâçÊôØËâ≤
                                            let savedForegroundColor;
                                            await executeAsModal(async () => {
                                                const foregroundColor = app.foregroundColor;
                                                savedForegroundColor = {
                                                    hue: {
                                                        _unit: "angleUnit",
                                                        _value: foregroundColor.hsb.hue
                                                    },
                                                    saturation: foregroundColor.hsb.saturation,
                                                    brightness: foregroundColor.hsb.brightness
                                                };
                                            });

                                            // 2. ÊòæÁ§∫È¢úËâ≤ÈÄâÊã©Âô®
                                            const result = await require("photoshop").core.executeAsModal(async (executionControl, descriptor) => {
                                                return await batchPlay(
                                                    [{
                                                        _obj: "showColorPicker",
                                                        _target: [{
                                                            _ref: "application"
                                                        }]
                                                    }],
                                                    {}
                                                );
                                            });
                                        
                                            // 3. Â§ÑÁêÜÈ¢úËâ≤ÈÄâÊã©ÁªìÊûú
                                            if (result && result[0] && result[0].RGBFloatColor) {
                                                const { red, grain, blue } = result[0].RGBFloatColor;
                                                this.setState({
                                                    strokeColor: {
                                                        red: Math.round(red),
                                                        green: Math.round(grain),
                                                        blue: Math.round(blue)
                                                    }
                                                });
                                            }

                                            // 4. ÊÅ¢Â§çÂâçÊôØËâ≤
                                            if (savedForegroundColor) {
                                                await executeAsModal(async () => {
                                                    await batchPlay(
                                                        [{
                                                            _obj: "set",
                                                            _target: [{
                                                                _ref: "color",
                                                                _property: "foregroundColor"
                                                            }],
                                                            to: {
                                                                _obj: "HSBColorClass",
                                                                hue: savedForegroundColor.hue,
                                                                saturation: savedForegroundColor.saturation,
                                                                brightness: savedForegroundColor.brightness
                                                            },
                                                            source: "photoshopPicker",
                                                            _options: {
                                                                dialogOptions: "dontDisplay"
                                                            }
                                                        }],
                                                        { synchronousExecution: true }
                                                    );
                                                }, { commandName: "ÊÅ¢Â§çÂâçÊôØËâ≤" });
                                            }
                                        } catch (error) {
                                            console.error('È¢úËâ≤ÈÄâÊã©Âô®ÈîôËØØ:', error);
                                        }
                                    }}/>
                                <sp-action-button 
                                    quiet 
                                    className="stroke-settings-icon"
                                    onClick={this.toggleStrokeSetting}
                                    title="ÊâìÂºÄÊèèËæπËÆæÁΩÆÈù¢ÊùøÔºåË∞ÉÊï¥ÊèèËæπÂÆΩÂ∫¶„ÄÅ‰ΩçÁΩÆÁ≠âÂèÇÊï∞„ÄÇ"
                                >
                                    <SettingsIcon/>
                                </sp-action-button>
                                </div>
                            )}
                            <sp-switch 
                                checked={this.state.strokeEnabled}
                                onChange={this.toggleStrokeEnabled}
                                title="ÂºÄÂêØÊèèËæπÊ®°ÂºèÔºåÂú®Â°´ÂÖÖÂêéËá™Âä®‰∏∫ÈÄâÂå∫ËæπÁºòÂ¢ûÂä†ÊèèËæπÊïàÊûú„ÄÇ"
                            />
                        </div>

                        {/* Ê∏ÖÈô§Ê®°ÂºèÂºÄÂÖ≥ */}
                        <div className="switch-container">
                            <label className="switch-label" 
title={`‚óè ÂºÄÂêØÊ∏ÖÈô§Ê®°ÂºèÔºå‰ª•‰∏ãÊñπÈÄâÊã©ÁöÑÊ®°ÂºèÂà†Èô§ÈÄâÂå∫ÂÜÖÂÆπ„ÄÇ

‚óè ÂÖ≥Èó≠Ê∏ÖÈô§Ê®°ÂºèÁöÑÊÉÖÂÜµ‰∏ãÁß∞‰ΩúÂ°´ÂÖÖÊ®°ÂºèÔºåÂ°´ÂÖÖÊ®°Âºè‰∏éÊ∏ÖÈô§Ê®°ÂºèÊîØÊåÅ‰øÆÊîπÂÉèÁ¥†ÂõæÂ±Ç„ÄÅÁ∫¢„ÄÅÁªø„ÄÅËìùÈÄöÈÅì„ÄÅÂø´ÈÄüËíôÁâàÔºåÂõæÂ±ÇËíôÁâà„ÄÅÁî®Êà∑‰øùÂ≠òÁöÑÈÄâÂå∫ÁöÑËá™ÂÆö‰πâalphaÈÄöÈÅì„ÄÇ

‚óè Ê∏ÖÈô§Ê®°ÂºèÁöÑËÆ°ÁÆóÊñπÊ≥ïÈááÂèñÁªùÂØπËÆ°ÁÆóÔºåÂØπÁ∫ØËâ≤„ÄÅÂõæÊ°à‰∏éÊ∏êÂèòÂú®‰øùÁïô‰∏çÈÄèÊòéÂ∫¶ÁöÑÂü∫Á°Ä‰∏äÈááÁî®Áªü‰∏ÄÁöÑÈÄªËæëÔºöÂÖàËΩ¨Âåñ‰∏∫ÁÅ∞Â∫¶ÔºåÁôΩËâ≤‰ª£Ë°®100%Âà†Èô§ÔºåÈªëËâ≤‰ª£Ë°®ÂÆåÂÖ®‰∏çÂà†Èô§„ÄÇ
ÔºàÂõ†Ê≠§Âà†Èô§Á∫ØËâ≤ÔºåÈúÄË¶ÅÂÖàÊääÂâçÊôØËâ≤ËÆæ‰∏∫ÁôΩËâ≤Ôºâ

‚óè Êú™Êù•ËÄÉËôëÂ¢ûÂä†Áõ∏ÂØπËÆ°ÁÆóÊ®°ÂºèÔºåÂç≥ËÄÉËôë‰∏Ä‰∏™Âà†Èô§Á≥ªÊï∞ÔºåÂΩìË¢´Âà†Èô§ÂØπË±°ÁöÑÈ¢úËâ≤ÁöÑÁÅ∞Â∫¶Ë∂äÈ´òÔºàÊàñ‰∏çÈÄèÊòéÂ∫¶Ë∂äÈ´òÔºâÔºåÂÆÉË¢´Âà†Èô§ÁöÑÁôæÂàÜÊØîË∂äÈ´ò„ÄÇ

‚óè Ê∏ÖÈô§Ê®°Âºè‰∏éÊñ∞Âª∫ÂõæÂ±ÇÊ®°Âºè‰∫íÊñ•Ôºå‰∏çËÉΩÂêåÊó∂ÂºÄÂêØ„ÄÇ`
}>
                            Ê∏ÖÈô§Ê®°Âºè
                            </label>
                            <sp-switch 
                                checked={this.state.clearMode}
                                onChange={this.toggleClearMode}
                                disabled={this.state.createNewLayer}
                                title="ÂºÄÂêØÊ∏ÖÈô§Ê®°ÂºèÔºå‰ª•‰∏ãÊñπÈÄâÊã©ÁöÑÊ®°ÂºèÂà†Èô§ÈÄâÂå∫ÂÜÖÂÆπ„ÄÇ"
                            />
                        </div>

                        {/* Â°´ÂÖÖÊ®°ÂºèÈÄâÊã© */}
                        <div className="fill-mode-group">
                            <div className="radio-group-label" title="ÈÄâÊã©Â°´ÂÖÖÁ±ªÂûãÔºöÁ∫ØËâ≤„ÄÅÂõæÊ°àÊàñÊ∏êÂèò„ÄÇ">Â°´ÂÖÖÊ®°Âºè</div>
                            <sp-radio-group 
                                selected={this.state.fillMode} 
                                name="fillMode"
                                onChange={this.handleFillModeChange}
                            >
                                <sp-radio value="foreground" className="radio-item" title="‰ΩøÁî®„ÄêÁ∫ØËâ≤„ÄëÊîπÂÜôÈÄâÂå∫‰∏≠ÁöÑÂÜÖÂÆπ„ÄÇ">
                                    <span className="radio-item-label" 
title={`‚óè Âü∫Á°ÄÁöÑÁ∫ØËâ≤Â°´ÂÖÖÊ®°ÂºèÔºåÂΩìÁõëÊµãÂà∞ÁîüÊàêÈÄâÂå∫ÂêéÔºåÁ´ãÂàªÂ°´ÂÖÖÂâçÊôØËâ≤„ÄÇ

‚óè Âè≥‰æßÁöÑÁ∫ØËâ≤ÂèÇÊï∞Èù¢ÊùøÔºåÈÄöËøáÁÆóÊ≥ï‰ΩøÂæóÊØèÊ¨°Ëá™Âä®Â°´ÂÖÖ‰ºö‰ª•ÂΩìÂâçÂâçÊôØËâ≤‰Ωú‰∏∫ÂéüÁÇπÔºåÂú®ÂèÇÊï∞ËÆæÂÆöÁöÑÈ¢úËâ≤Âå∫Èó¥ÂÜÖÈöèÊú∫ÈÄâÊã©È¢úËâ≤Â°´ÂÖÖ„ÄÇ

‚óè ÁºñËæëRGBÈÄöÈÅìÊó∂Ôºå‰ºöÊèê‰æõ4‰∏™ÂèØÁºñËæëÈÄâÈ°π„ÄÇÂú®ÁºñËæëËíôÁâàÁ≠âÁÅ∞Â∫¶ÈÄöÈÅìÊó∂ÔºåÂè™Êèê‰æõ2‰∏™ÂèØÁºñËæëÈÄâÈ°π„ÄÇ`
}>
                                    Á∫ØËâ≤
                                    </span>
                                    <sp-action-button 
                                        quiet 
                                        className="settings-icon"
                                        onClick={this.toggleColorSettings}
                                        title="ÊâìÂºÄÁ∫ØËâ≤ËÆæÁΩÆÈù¢ÊùøÔºåË∞ÉÊï¥Á∫ØËâ≤ÂèòÂåñÂèÇÊï∞„ÄÇ"
                                    >
                                        <SettingsIcon/>
                                    </sp-action-button>
                                </sp-radio>
                                <sp-radio value="pattern" className="radio-item" title="‰ΩøÁî®„ÄêÂõæÊ°à„ÄëÊîπÂÜôÈÄâÂå∫‰∏≠ÁöÑÂÜÖÂÆπ„ÄÇ">
                                    <span className="radio-item-label" 
title={`‚óè ÂõæÊ°àÂ°´ÂÖÖÊ®°ÂºèÔºåÈúÄË¶ÅÁî®Êà∑Áî®Á≥ªÁªü‰∏≠Âä†ËΩΩjpg„ÄÅpngÁ≠âÂõæÁâáÊñá‰ª∂Ôºå‰Ωú‰∏∫ÂõæÊ°àÁöÑÈ¢ÑËÆæ„ÄÇ
    
‚óè Áî±‰∫éÂõæÊ°àÊé•Âè£Êú™ÂºÄÊîæÔºåÂΩìÂâçÁâàÊú¨‰∏çÊîØÊåÅPSÂÜÖÈÉ®ÁöÑÂõæÊ°à„ÄÇ
    
‚óè ÊîØÊåÅShiftÔºåCtrlÁ≠â‰øÆÊîπÈîÆÂ§öÈÄâÁÆ°ÁêÜÈ¢ÑËÆæ„ÄÇ

‚óè Êèê‰æõ‰∏§Áßç‰∏çÂêåÁöÑÂ°´ÂÖÖÊñπÊ°àÔºåÊîØÊåÅÊóãËΩ¨‰∏éÁº©ÊîæÔºõÊîØÊåÅPNGÁöÑ‰∏çÈÄèÊòéÂ∫¶ÈÄöÈÅì„ÄÇ

‚óè ÂΩìÂâçPSÊ≤°ÊúâÂºÄÊîæÈ¢ÑËßàÊóãËΩ¨ÂõæÊ°àÁöÑÊé•Âè£ÔºåÂΩìÂºÄÊîæÂêé‰ºöË∑üËøõ„ÄÇ`
}>
                                    ÂõæÊ°à
                                    </span>
                                    <sp-action-button 
                                        quiet 
                                        className="settings-icon"
                                        onClick={this.openPatternPicker}
                                        title="ÊâìÂºÄÂõæÊ°àÈù¢ÊùøÔºåÁÆ°ÁêÜÂõæÊ°àÈ¢ÑËÆæÔºåËÆæÁΩÆÁõ∏ÂÖ≥ÁöÑÂèÇÊï∞„ÄÇ"
                                    >
                                        <SettingsIcon/>
                                    </sp-action-button>
                                </sp-radio>
                                <sp-radio value="gradient" className="radio-item" title="‰ΩøÁî®„ÄêÊ∏êÂèò„ÄëÊîπÂÜôÈÄâÂå∫‰∏≠ÁöÑÂÜÖÂÆπ„ÄÇ">
                                    <span className="radio-item-label" 
title={`‚óè Ê∏êÂèòÂ°´ÂÖÖÊ®°ÂºèÔºåÈúÄË¶ÅÁî®Êà∑Ëá™Ë°åËÆæÁΩÆÊ∏êÂèòÁöÑËµ∑ÂßãÈ¢úËâ≤„ÄÅÁªìÊùüÈ¢úËâ≤„ÄÅËßíÂ∫¶Á≠âÂèÇÊï∞Ôºå‰ª•Âà∂‰ΩúÊ∏êÂèòÁöÑÈ¢ÑËÆæ„ÄÇ

‚óè Â∑≤ÁªèÂ≠òÂú®ÁöÑÊ∏êÂèòÈ¢ÑËÆæÔºåÂèØ‰ª•ÁÇπÂáªÈÄâ‰∏≠ÂêéÔºå‰øÆÊîπÈù¢Êùø‰∏≠ÁöÑÂèÇÊï∞‰ª•‰øÆÊîπÈ¢ÑËÆæ„ÄÇ   

‚óè ÂèØ‰ª•ÁÇπÂáªÊ∏êÂèòÊù°Â¢ûÂä†ÊªëÂùóÔºå‰∏çÈÄèÊòéÂ∫¶‰∏éÈ¢úËâ≤ÊªëÂùó‰∏Ä‰∏ÄÂØπÂ∫îÔºåÁî±‰∫éÈúÄË¶ÅÁªü‰∏ÄÈÄªËæëÔºåÊèí‰ª∂‰∏≠‰∏çÈÄèÊòéÂ∫¶ÊªëÂùóÁôΩËâ≤‰ª£Ë°®100%‰∏çÈÄèÊòéÔºåÈªëËâ≤‰ª£Ë°®ÂÆåÂÖ®ÈÄèÊòé„ÄÇ
    
‚óè ÁÇπÂáªÊ∏êÂèòÈ¢ÑËÆæÂå∫ÁöÑÁ©∫ÁôΩÂèØ‰ª•ÂèñÊ∂àÈÄâÊã©„ÄÇÊîØÊåÅShiftÔºåCtrlÁ≠â‰øÆÊîπÈîÆÂ§öÈÄâÁÆ°ÁêÜÈ¢ÑËÆæ„ÄÇ

‚óè Áî±‰∫éÊ∏êÂèòÊé•Âè£Êú™ÂºÄÊîæÔºåÂΩìÂâçÁâàÊú¨‰∏çÊîØÊåÅPSÂÜÖÈÉ®ÁöÑÊ∏êÂèòÈ¢ÑËÆæÔºõÁî±‰∫éÊµèËßàÂô®ÁöÑÈóÆÈ¢òÔºåÊ∏êÂèòÁöÑÁßçÁ±ªÊöÇÊó∂Âè™ÊîØÊåÅÁ∫øÊÄß‰∏éÂæÑÂêë‰∏§ÁßçÔºåÊú™Êù•ÂèØËÉΩ‰ºöË°•ÂÖÖÂÖ∂‰ªñÁ±ªÂûãÁöÑÊ∏êÂèò„ÄÇ`
}>
                                    Ê∏êÂèò
                                    </span>
                                    <sp-action-button 
                                        quiet 
                                        className="settings-icon"
                                        onClick={this.openGradientPicker}
                                        title="ÊâìÂºÄÊ∏êÂèòÈÄâÊã©Âô®ÔºåËÆæÁΩÆÊ∏êÂèòÈ¢ÑËÆæ‰∏éËßíÂ∫¶Á≠âÂèÇÊï∞„ÄÇ"
                                    >
                                        <SettingsIcon/>
                                    </sp-action-button>
                                </sp-radio>
                            </sp-radio-group>
                        </div>

                        {/* Â∫ïÈÉ®ÈÄâÈ°π */}
                        <div className="bottom-options">
                            <div className="checkbox-container">
                                 <label 
                                    htmlFor="deselectCheckbox" 
                                    className="checkbox-label"
                                    onClick={this.toggleDeselectAfterFill} // Ê∑ªÂä† onClick ‰∫ã‰ª∂Â§ÑÁêÜÁ®ãÂ∫è
                                      title="Â°´ÂÖÖÂÆåÊàêÂêéËá™Âä®ÂèñÊ∂àÈÄâÂå∫„ÄÇ
ÂèñÊ∂àÂãæÈÄâÂêé‰ºö‰øùÁïôÂ∑≤Áªè‰øÆÊîπÂêéÁöÑÈÄâÂå∫ÔºåËÄå‰∏çÊòØÊúÄÂàùÁîüÊàêÁöÑÈÄâÂå∫„ÄÇ"
                                >
                                    ÂèñÊ∂àÈÄâÂå∫:
                                </label>
                                <input
                                    type='checkbox'
                                    id="deselectCheckbox"
                                    checked={this.state.deselectAfterFill}
                                    onChange={this.toggleDeselectAfterFill}
                                    className="checkbox-input"
                                    title="ÂàáÊç¢Ëá™Âä®ÂèñÊ∂àÈÄâÂå∫ÁöÑÁä∂ÊÄÅ„ÄÇ"
                                />
                                
                            </div>
                            <div className="checkbox-container">
                                <label 
                                    htmlFor="historyCheckbox" 
                                    className="checkbox-label"
                                    onClick={this.toggleAutoUpdateHistory} // Ê∑ªÂä† onClick ‰∫ã‰ª∂Â§ÑÁêÜÁ®ãÂ∫è
                                    title="Ëá™Âä®ÊääÂéÜÂè≤ËÆ∞ÂΩïÁîªÁ¨îÁöÑÊ∫êÂõæÂÉèËÆæÁΩÆ‰∏∫ÊØèÊ¨°ÁîüÊàêÈÄâÂå∫ÁöÑÈÇ£‰∏ÄÂàªÔºå
‰ªéËÄåÂèØ‰ª•ÁªìÂêàÂéÜÂè≤ËÆ∞ÂΩïÁîªÁ¨îÂ¢ûÂº∫ÊàñËÄÖÂâäÂº±Êú¨Ê¨°Â°´ÂÖÖÁöÑÊïàÊûú„ÄÇ"
                                >
                                    Êõ¥Êñ∞ÂéÜÂè≤Ê∫ê:
                                </label>
                                <input
                                    type='checkbox'
                                    id="historyCheckbox"
                                    checked={this.state.autoUpdateHistory}
                                    onChange={this.toggleAutoUpdateHistory}
                                    className="checkbox-input"
                                    title="ÂàáÊç¢Ëá™Âä®Êõ¥Êñ∞ÂéÜÂè≤ËÆ∞ÂΩïÁîªÁ¨îÁöÑÊ∫êÂõæÂÉèÁöÑÁä∂ÊÄÅ„ÄÇ"

                                />
                            </div>
                        </div>
                    </div>
                </div>
                
            <div className="info-plane">
            <span className="copyright">Copyright ¬© listen2me (JW)</span>
        </div>

            {/* È¢úËâ≤ËÆæÁΩÆÈù¢Êùø */}
            <ColorSettingsPanel 
                isOpen={this.state?.isColorSettingsOpen ?? false} 
                onClose={this.closeColorSettings} 
                onSave={this.handleColorSettingsSave} 
                initialSettings={this.state?.colorSettings ?? {
                    hueVariation: 0,
                    saturationVariation: 0,
                    brightnessVariation: 0,
                    opacityVariation: 0,
                    grayVariation: 0,
                    calculationMode: 'absolute'
                }}
                isClearMode={this.state.clearMode}
                isQuickMaskMode={false}
            />

            {/* ÂõæÊ°àÈÄâÊã©Âô® */}
            <PatternPicker 
                isOpen={this.state?.isPatternPickerOpen ?? false} 
                onClose={this.closePatternPicker} 
                onSelect={this.handlePatternSelect} 
                isClearMode={this.state.clearMode}
            />

            {/* Ê∏êÂèòÈÄâÊã©Âô® */}
            <GradientPicker 
                isOpen={this.state?.isGradientPickerOpen ?? false}    
                onClose={this.closeGradientPicker} 
                onSelect={this.handleGradientSelect} 
                isClearMode={this.state.clearMode}
            />

                {/* ÊèèËæπËÆæÁΩÆÈù¢Êùø */}
            <StrokeSetting
              isOpen={this.state.isStrokeSettingOpen ?? false}
              width={this.state.strokeWidth}
              position={this.state.strokePosition}
              blendMode={this.state.strokeBlendMode}
              opacity={this.state.strokeOpacity}
              clearMode={this.state.clearMode}
              onWidthChange={(width) => this.setState({ strokeWidth: width })}
              onPositionChange={(position) => this.setState({ strokePosition: position })}
              onBlendModeChange={(blendMode) => this.setState({ strokeBlendMode: blendMode })}
              onOpacityChange={(opacity) => this.setState({ strokeOpacity: opacity })}
              onClose={this.closeStrokeSetting}
            />
        </div>
        );
    }
}

export default App;